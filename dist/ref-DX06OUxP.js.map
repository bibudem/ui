{"version":3,"file":"ref-DX06OUxP.js","sources":["../node_modules/lit-html/development/directive-helpers.js","../node_modules/lit-html/development/async-directive.js","../node_modules/lit-html/development/directives/ref.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { _$LH, } from './lit-html.js';\nconst { _ChildPart: ChildPart } = _$LH;\nconst ENABLE_SHADYDOM_NOPATCH = true;\nconst wrap = ENABLE_SHADYDOM_NOPATCH &&\n    window.ShadyDOM?.inUse &&\n    window.ShadyDOM?.noPatch === true\n    ? window.ShadyDOM.wrap\n    : (node) => node;\n/**\n * Tests if a value is a primitive value.\n *\n * See https://tc39.github.io/ecma262/#sec-typeof-operator\n */\nexport const isPrimitive = (value) => value === null || (typeof value != 'object' && typeof value != 'function');\nexport const TemplateResultType = {\n    HTML: 1,\n    SVG: 2,\n};\n/**\n * Tests if a value is a TemplateResult or a CompiledTemplateResult.\n */\nexport const isTemplateResult = (value, type) => type === undefined\n    ? // This property needs to remain unminified.\n        value?.['_$litType$'] !== undefined\n    : value?.['_$litType$'] === type;\n/**\n * Tests if a value is a CompiledTemplateResult.\n */\nexport const isCompiledTemplateResult = (value) => {\n    return value?.['_$litType$']?.h != null;\n};\n/**\n * Tests if a value is a DirectiveResult.\n */\nexport const isDirectiveResult = (value) => \n// This property needs to remain unminified.\nvalue?.['_$litDirective$'] !== undefined;\n/**\n * Retrieves the Directive class for a DirectiveResult\n */\nexport const getDirectiveClass = (value) => \n// This property needs to remain unminified.\nvalue?.['_$litDirective$'];\n/**\n * Tests whether a part has only a single-expression with no strings to\n * interpolate between.\n *\n * Only AttributePart and PropertyPart can have multiple expressions.\n * Multi-expression parts have a `strings` property and single-expression\n * parts do not.\n */\nexport const isSingleExpression = (part) => part.strings === undefined;\nconst createMarker = () => document.createComment('');\n/**\n * Inserts a ChildPart into the given container ChildPart's DOM, either at the\n * end of the container ChildPart, or before the optional `refPart`.\n *\n * This does not add the part to the containerPart's committed value. That must\n * be done by callers.\n *\n * @param containerPart Part within which to add the new ChildPart\n * @param refPart Part before which to add the new ChildPart; when omitted the\n *     part added to the end of the `containerPart`\n * @param part Part to insert, or undefined to create a new part\n */\nexport const insertPart = (containerPart, refPart, part) => {\n    const container = wrap(containerPart._$startNode).parentNode;\n    const refNode = refPart === undefined ? containerPart._$endNode : refPart._$startNode;\n    if (part === undefined) {\n        const startNode = wrap(container).insertBefore(createMarker(), refNode);\n        const endNode = wrap(container).insertBefore(createMarker(), refNode);\n        part = new ChildPart(startNode, endNode, containerPart, containerPart.options);\n    }\n    else {\n        const endNode = wrap(part._$endNode).nextSibling;\n        const oldParent = part._$parent;\n        const parentChanged = oldParent !== containerPart;\n        if (parentChanged) {\n            part._$reparentDisconnectables?.(containerPart);\n            // Note that although `_$reparentDisconnectables` updates the part's\n            // `_$parent` reference after unlinking from its current parent, that\n            // method only exists if Disconnectables are present, so we need to\n            // unconditionally set it here\n            part._$parent = containerPart;\n            // Since the _$isConnected getter is somewhat costly, only\n            // read it once we know the subtree has directives that need\n            // to be notified\n            let newConnectionState;\n            if (part._$notifyConnectionChanged !== undefined &&\n                (newConnectionState = containerPart._$isConnected) !==\n                    oldParent._$isConnected) {\n                part._$notifyConnectionChanged(newConnectionState);\n            }\n        }\n        if (endNode !== refNode || parentChanged) {\n            let start = part._$startNode;\n            while (start !== endNode) {\n                const n = wrap(start).nextSibling;\n                wrap(container).insertBefore(start, refNode);\n                start = n;\n            }\n        }\n    }\n    return part;\n};\n/**\n * Sets the value of a Part.\n *\n * Note that this should only be used to set/update the value of user-created\n * parts (i.e. those created using `insertPart`); it should not be used\n * by directives to set the value of the directive's container part. Directives\n * should return a value from `update`/`render` to update their part state.\n *\n * For directives that require setting their part value asynchronously, they\n * should extend `AsyncDirective` and call `this.setValue()`.\n *\n * @param part Part to set\n * @param value Value to set\n * @param index For `AttributePart`s, the index to set\n * @param directiveParent Used internally; should not be set by user\n */\nexport const setChildPartValue = (part, value, directiveParent = part) => {\n    part._$setValue(value, directiveParent);\n    return part;\n};\n// A sentinel value that can never appear as a part value except when set by\n// live(). Used to force a dirty-check to fail and cause a re-render.\nconst RESET_VALUE = {};\n/**\n * Sets the committed value of a ChildPart directly without triggering the\n * commit stage of the part.\n *\n * This is useful in cases where a directive needs to update the part such\n * that the next update detects a value change or not. When value is omitted,\n * the next update will be guaranteed to be detected as a change.\n *\n * @param part\n * @param value\n */\nexport const setCommittedValue = (part, value = RESET_VALUE) => (part._$committedValue = value);\n/**\n * Returns the committed value of a ChildPart.\n *\n * The committed value is used for change detection and efficient updates of\n * the part. It can differ from the value set by the template or directive in\n * cases where the template value is transformed before being committed.\n *\n * - `TemplateResult`s are committed as a `TemplateInstance`\n * - Iterables are committed as `Array<ChildPart>`\n * - All other types are committed as the template value or value returned or\n *   set by a directive.\n *\n * @param part\n */\nexport const getCommittedValue = (part) => part._$committedValue;\n/**\n * Removes a ChildPart from the DOM, including any of its content.\n *\n * @param part The Part to remove\n */\nexport const removePart = (part) => {\n    part._$notifyConnectionChanged?.(false, true);\n    let start = part._$startNode;\n    const end = wrap(part._$endNode).nextSibling;\n    while (start !== end) {\n        const n = wrap(start).nextSibling;\n        wrap(start).remove();\n        start = n;\n    }\n};\nexport const clearPart = (part) => {\n    part._$clear();\n};\n//# sourceMappingURL=directive-helpers.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { isSingleExpression } from './directive-helpers.js';\nimport { Directive, PartType } from './directive.js';\nexport * from './directive.js';\nconst DEV_MODE = true;\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (parent, isConnected) => {\n    const children = parent._$disconnectableChildren;\n    if (children === undefined) {\n        return false;\n    }\n    for (const obj of children) {\n        // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n        // disambiguate AsyncDirectives from other DisconnectableChildren\n        // (as opposed to using an instanceof check to know when to call it); the\n        // redundancy of \"Directive\" in the API name is to avoid conflicting with\n        // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n        // this list\n        // Disconnect Directive (and any nested directives contained within)\n        // This property needs to remain unminified.\n        obj['_$notifyDirectiveConnectionChanged']?.(isConnected, false);\n        // Disconnect Part/TemplateInstance\n        notifyChildrenConnectedChanged(obj, isConnected);\n    }\n    return true;\n};\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = (obj) => {\n    let parent, children;\n    do {\n        if ((parent = obj._$parent) === undefined) {\n            break;\n        }\n        children = parent._$disconnectableChildren;\n        children.delete(obj);\n        obj = parent;\n    } while (children?.size === 0);\n};\nconst addDisconnectableToParent = (obj) => {\n    // Climb the parent tree, creating a sparse tree of children needing\n    // disconnection\n    for (let parent; (parent = obj._$parent); obj = parent) {\n        let children = parent._$disconnectableChildren;\n        if (children === undefined) {\n            parent._$disconnectableChildren = children = new Set();\n        }\n        else if (children.has(obj)) {\n            // Once we've reached a parent that already contains this child, we\n            // can short-circuit\n            break;\n        }\n        children.add(obj);\n        installDisconnectAPI(parent);\n    }\n};\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(newParent) {\n    if (this._$disconnectableChildren !== undefined) {\n        removeDisconnectableFromParent(this);\n        this._$parent = newParent;\n        addDisconnectableToParent(this);\n    }\n    else {\n        this._$parent = newParent;\n    }\n}\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {\n    const value = this._$committedValue;\n    const children = this._$disconnectableChildren;\n    if (children === undefined || children.size === 0) {\n        return;\n    }\n    if (isClearingValue) {\n        if (Array.isArray(value)) {\n            // Iterable case: Any ChildParts created by the iterable should be\n            // disconnected and removed from this ChildPart's disconnectable\n            // children (starting at `fromPartIndex` in the case of truncation)\n            for (let i = fromPartIndex; i < value.length; i++) {\n                notifyChildrenConnectedChanged(value[i], false);\n                removeDisconnectableFromParent(value[i]);\n            }\n        }\n        else if (value != null) {\n            // TemplateInstance case: If the value has disconnectable children (will\n            // only be in the case that it is a TemplateInstance), we disconnect it\n            // and remove it from this ChildPart's disconnectable children\n            notifyChildrenConnectedChanged(value, false);\n            removeDisconnectableFromParent(value);\n        }\n    }\n    else {\n        notifyChildrenConnectedChanged(this, isConnected);\n    }\n}\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = (obj) => {\n    if (obj.type == PartType.CHILD) {\n        obj._$notifyConnectionChanged ??=\n            notifyChildPartConnectedChanged;\n        obj._$reparentDisconnectables ??= reparentDisconnectables;\n    }\n};\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport class AsyncDirective extends Directive {\n    constructor() {\n        super(...arguments);\n        // @internal\n        this._$disconnectableChildren = undefined;\n    }\n    /**\n     * Initialize the part with internal fields\n     * @param part\n     * @param parent\n     * @param attributeIndex\n     */\n    _$initialize(part, parent, attributeIndex) {\n        super._$initialize(part, parent, attributeIndex);\n        addDisconnectableToParent(this);\n        this.isConnected = part._$isConnected;\n    }\n    // This property needs to remain unminified.\n    /**\n     * Called from the core code when a directive is going away from a part (in\n     * which case `shouldRemoveFromParent` should be true), and from the\n     * `setChildrenConnected` helper function when recursively changing the\n     * connection state of a tree (in which case `shouldRemoveFromParent` should\n     * be false).\n     *\n     * @param isConnected\n     * @param isClearingDirective - True when the directive itself is being\n     *     removed; false when the tree is being disconnected\n     * @internal\n     */\n    ['_$notifyDirectiveConnectionChanged'](isConnected, isClearingDirective = true) {\n        if (isConnected !== this.isConnected) {\n            this.isConnected = isConnected;\n            if (isConnected) {\n                this.reconnected?.();\n            }\n            else {\n                this.disconnected?.();\n            }\n        }\n        if (isClearingDirective) {\n            notifyChildrenConnectedChanged(this, isConnected);\n            removeDisconnectableFromParent(this);\n        }\n    }\n    /**\n     * Sets the value of the directive's Part outside the normal `update`/`render`\n     * lifecycle of a directive.\n     *\n     * This method should not be called synchronously from a directive's `update`\n     * or `render`.\n     *\n     * @param directive The directive to update\n     * @param value The value to set\n     */\n    setValue(value) {\n        if (isSingleExpression(this.__part)) {\n            this.__part._$setValue(value, this);\n        }\n        else {\n            // this.__attributeIndex will be defined in this case, but\n            // assert it in dev mode\n            if (DEV_MODE && this.__attributeIndex === undefined) {\n                throw new Error(`Expected this.__attributeIndex to be a number`);\n            }\n            const newValues = [...this.__part._$committedValue];\n            newValues[this.__attributeIndex] = value;\n            this.__part._$setValue(newValues, this, 0);\n        }\n    }\n    /**\n     * User callbacks for implementing logic to release any resources/subscriptions\n     * that may have been retained by this directive. Since directives may also be\n     * re-connected, `reconnected` should also be implemented to restore the\n     * working state of the directive prior to the next render.\n     */\n    disconnected() { }\n    reconnected() { }\n}\n//# sourceMappingURL=async-directive.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { nothing } from '../lit-html.js';\nimport { directive, AsyncDirective } from '../async-directive.js';\n/**\n * Creates a new Ref object, which is container for a reference to an element.\n */\nexport const createRef = () => new Ref();\n/**\n * An object that holds a ref value.\n */\nclass Ref {\n}\n// When callbacks are used for refs, this map tracks the last value the callback\n// was called with, for ensuring a directive doesn't clear the ref if the ref\n// has already been rendered to a new spot. It is double-keyed on both the\n// context (`options.host`) and the callback, since we auto-bind class methods\n// to `options.host`.\nconst lastElementForContextAndCallback = new WeakMap();\nclass RefDirective extends AsyncDirective {\n    render(_ref) {\n        return nothing;\n    }\n    update(part, [ref]) {\n        const refChanged = ref !== this._ref;\n        if (refChanged && this._ref !== undefined) {\n            // The ref passed to the directive has changed;\n            // unset the previous ref's value\n            this._updateRefValue(undefined);\n        }\n        if (refChanged || this._lastElementForRef !== this._element) {\n            // We either got a new ref or this is the first render;\n            // store the ref/element & update the ref value\n            this._ref = ref;\n            this._context = part.options?.host;\n            this._updateRefValue((this._element = part.element));\n        }\n        return nothing;\n    }\n    _updateRefValue(element) {\n        if (typeof this._ref === 'function') {\n            // If the current ref was called with a previous value, call with\n            // `undefined`; We do this to ensure callbacks are called in a consistent\n            // way regardless of whether a ref might be moving up in the tree (in\n            // which case it would otherwise be called with the new value before the\n            // previous one unsets it) and down in the tree (where it would be unset\n            // before being set). Note that element lookup is keyed by\n            // both the context and the callback, since we allow passing unbound\n            // functions that are called on options.host, and we want to treat\n            // these as unique \"instances\" of a function.\n            const context = this._context ?? globalThis;\n            let lastElementForCallback = lastElementForContextAndCallback.get(context);\n            if (lastElementForCallback === undefined) {\n                lastElementForCallback = new WeakMap();\n                lastElementForContextAndCallback.set(context, lastElementForCallback);\n            }\n            if (lastElementForCallback.get(this._ref) !== undefined) {\n                this._ref.call(this._context, undefined);\n            }\n            lastElementForCallback.set(this._ref, element);\n            // Call the ref with the new element value\n            if (element !== undefined) {\n                this._ref.call(this._context, element);\n            }\n        }\n        else {\n            this._ref.value = element;\n        }\n    }\n    get _lastElementForRef() {\n        return typeof this._ref === 'function'\n            ? lastElementForContextAndCallback\n                .get(this._context ?? globalThis)\n                ?.get(this._ref)\n            : this._ref?.value;\n    }\n    disconnected() {\n        // Only clear the box if our element is still the one in it (i.e. another\n        // directive instance hasn't rendered its element to it before us); that\n        // only happens in the event of the directive being cleared (not via manual\n        // disconnection)\n        if (this._lastElementForRef === this._element) {\n            this._updateRefValue(undefined);\n        }\n    }\n    reconnected() {\n        // If we were manually disconnected, we can safely put our element back in\n        // the box, since no rendering could have occurred to change its state\n        this._updateRefValue(this._element);\n    }\n}\n/**\n * Sets the value of a Ref object or calls a ref callback with the element it's\n * bound to.\n *\n * A Ref object acts as a container for a reference to an element. A ref\n * callback is a function that takes an element as its only argument.\n *\n * The ref directive sets the value of the Ref object or calls the ref callback\n * during rendering, if the referenced element changed.\n *\n * Note: If a ref callback is rendered to a different element position or is\n * removed in a subsequent render, it will first be called with `undefined`,\n * followed by another call with the new element it was rendered to (if any).\n *\n * ```js\n * // Using Ref object\n * const inputRef = createRef();\n * render(html`<input ${ref(inputRef)}>`, container);\n * inputRef.value.focus();\n *\n * // Using callback\n * const callback = (inputElement) => inputElement.focus();\n * render(html`<input ${ref(callback)}>`, container);\n * ```\n */\nexport const ref = directive(RefDirective);\n//# sourceMappingURL=ref.js.map"],"names":["window","ShadyDOM","inUse","noPatch","wrap","notifyChildrenConnectedChanged","parent","isConnected","children","_$disconnectableChildren","obj","removeDisconnectableFromParent","_$parent","delete","size","addDisconnectableToParent","Set","has","add","installDisconnectAPI","reparentDisconnectables","newParent","undefined","this","notifyChildPartConnectedChanged","isClearingValue","fromPartIndex","value","_$committedValue","Array","isArray","i","length","type","PartType","CHILD","_$notifyConnectionChanged","_$reparentDisconnectables","AsyncDirective","Directive","super","arguments","part","attributeIndex","_$initialize","_$isConnected","isClearingDirective","reconnected","disconnected","__part","strings","_$setValue","__attributeIndex","Error","newValues","createRef","Ref","lastElementForContextAndCallback","WeakMap","ref","directive","_ref","nothing","refChanged","_updateRefValue","_lastElementForRef","_element","_context","options","host","element","context","globalThis","lastElementForCallback","get","set","call"],"mappings":"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","x_google_ignoreList":[0,1,2]}