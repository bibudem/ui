{"version":3,"file":"consentClient.js","sources":["../src/components/bib-consent/consentClient.js"],"sourcesContent":["import { callServer } from 'postmessage-promise'\nimport { stringIsUrl } from '@/utils/url.js'\nimport { loggerFactory } from '@/utils/logger.js'\nimport getConsentStorage from './ConsentStorage.js'\nimport { ConsentTokens } from './ConsentTokens.js'\nimport { getIframeServer, getServerMode } from './utils.js'\nimport { EVENT_NAMES, SERVER_MODE, SERVER_REQUEST_DEFAULT_TIMEOUT } from './constants.js'\n\n/**\n * Represents a client for managing user consent tokens, with the ability to interact with a remote server or local storage.\n *\n * The `ConsentClient` class extends the `EventTarget` class, allowing it to dispatch events related to preference updates.\n *\n * Key features:\n * - Initialization with options for server mode (local or remote), server URL, and event reflection.\n * - Ability to add hosts that will receive preference update events.\n * - Debugging functionality with configurable debug mode.\n * - Methods to set, get, and reset user tokens, with different behavior based on server mode.\n *\n * @property {string} readyState - The current state of the ConsentClient instance. Can be 'initial', 'connecting' or 'ready'.\n */\nclass ConsentClient extends EventTarget {\n  _server\n  _storage\n  #debugIsOn = false\n  #debug\n\n  constructor() {\n    super()\n    this.readyState = 'initial'\n    this.hosts = []\n  }\n\n  addHost({ host, reflectEvents }) {\n    this.hosts.push({ host, reflectEvents })\n  }\n\n  debug() {\n    if (this.#debugIsOn) {\n      this.#debug(...arguments)\n    }\n  }\n\n  dispatchEvent(event) {\n    super.dispatchEvent(event)\n    // this.hosts.forEach(({ host, reflectEvents }) => reflectEvents && host.dispatchEvent?.(event))\n  }\n\n  /**\n   * Adds an event listener to the ConsentClient instance.\n   *\n   * If the event type is `EVENT_NAMES.READY` and the `readyState` is already `'ready'`, the listener function is called immediately with the current preferences object as the event detail.\n   *\n   * Otherwise, the event listener is added using the standard `addEventListener` method.\n   *\n   * @param {string} type - The type of event to listen for.\n   * @param {EventListener} listener - The function to call when the event is dispatched.\n   * @param {EventListenerOptions} [options] - Options for the event listener.\n   */\n  addEventListener(type, listener, options) {\n    if (type === EVENT_NAMES.READY && this.readyState === 'ready') {\n      this.debug('Firing ready event immediately since readyState is already ready')\n      this.#fireReadyListener(listener)\n      return\n    }\n\n    super.addEventListener(type, listener, options)\n  }\n\n  async #fireReadyListener(listener) {\n    const consentTokens = await this.getConsentTokens()\n    const readyEvent = new CustomEvent(EVENT_NAMES.READY, { detail: consentTokens, bubbles: true, composed: true })\n    this.debug('Firing ready event with preferences: ', consentTokens)\n    listener(readyEvent)\n  }\n\n  /**\n   * Initializes the ConsentClient instance with the provided options.\n   *\n   * @param {Object} options - The initialization options.\n   * @param {Object} [options.host] - The host object that will receive preference update events.\n   * @param {string} [options.serverMode] - The server mode, either 'LOCAL' or 'REMOTE'.\n   * @param {string} [options.serverUrl] - The URL of the remote server.\n   * @param {number} [options.serverRequestTimeout=SERVER_REQUEST_DEFAULT_TIMEOUT] - The timeout for server requests in milliseconds.\n   * @param {boolean} [options.reflectEvents=true] - Whether to reflect preference update events to the host.\n   * @returns {Promise<void>} - A promise that resolves when initialization is complete.\n   *\n   * @event EVENT_NAMES.READY - Dispatched when the initial preferences data is available. The event detail contains the preferences object.\n   * @event EVENT_NAMES.CHANGE - Dispatched when the preferences are updated. The event detail contains the updated preferences object.\n   */\n\n  async init({ host, serverMode, serverUrl, serverRequestTimeout = SERVER_REQUEST_DEFAULT_TIMEOUT, reflectEvents = true }) {\n    this.serverRequestTimeout = serverRequestTimeout\n\n    if (host) {\n      this.addHost({ host, reflectEvents })\n    }\n\n    this.readyState = 'connecting'\n\n    if (\n      (\n        serverMode && serverMode === SERVER_MODE.LOCAL\n      )\n      ||\n      typeof serverUrl === 'undefined'\n      ||\n      !stringIsUrl(serverUrl)\n    ) {\n      this.serverMode = SERVER_MODE.LOCAL\n    } else {\n      this.serverUrl = new URL(serverUrl, location)\n\n      if (host.debug) {\n        this.serverUrl.searchParams.set('debug', '')\n      }\n\n      this.serverMode = await getServerMode(this)\n\n    }\n\n    this.#debugIsOn = !!host.debug\n\n    if (this.#debugIsOn) {\n      this.#debug = loggerFactory('consentClient', 'purple')\n    }\n\n    this.debug('init', `server mode: ${this.serverMode}`)\n\n    let consentTokens\n\n    if (this.serverMode === SERVER_MODE.REMOTE) {\n      const serverObject = getIframeServer(document.body, this.serverUrl.href)\n\n      try {\n        this._server = await callServer(serverObject)\n\n        this._server.listenMessage((method, data) => {\n          const consentTokens = ConsentTokens.from(data)\n          const event = new CustomEvent(EVENT_NAMES.CHANGE, { detail: consentTokens, bubbles: true, composed: true })\n          this.dispatchEvent(event)\n        })\n      } catch (error) {\n        console.error('[callServer] error: ', error)\n        throw error\n      }\n\n      console.log('[consentClient] Server mode: %s', this.serverMode)\n      console.log('[consentClient] Remote consent server URL: %s', this.serverUrl.href)\n      console.log('[consentClient] this._server:', this._server)\n\n      consentTokens = ConsentTokens.from(await this._server.postMessage('getConsentTokens'))\n      this.debug('[remote] Got response from server: ', consentTokens)\n\n    } else {\n      this._storage = await getConsentStorage()\n\n      consentTokens = await this._storage.getConsentTokens()\n      this.debug('[local] Got response from storage: ', consentTokens)\n    }\n\n    this.debug('[local] consentTokens: ', consentTokens)\n\n    if (consentTokens !== undefined) {\n\n      // Dispatch initial data with the ready state.\n      this.readyState = 'ready'\n\n      this.dispatchEvent(new CustomEvent(EVENT_NAMES.READY, { detail: consentTokens, bubbles: true, composed: true }))\n    }\n  }\n\n  /**\n   * Gets the user's preferences from either the local storage or the remote server, depending on the configured server mode.\n   *\n   * @returns {Promise<Object>} - A promise that resolves with the user's preferences, or rejects with an error if the operation fails.\n   */\n  async getConsentTokens() {\n    try {\n      if (this.serverMode === SERVER_MODE.LOCAL) {\n        return await this._storage.getConsentTokens()\n      } else {\n        return ConsentTokens.from(await this._server.postMessage('getConsentTokens'))\n      }\n    } catch (error) {\n      console.error('[#getConsentTokens]', error)\n      throw error\n    }\n  }\n\n  /**\n  * Sets the user's tokens in either the local storage or the remote server, depending on the configured server mode.\n  *\n  * @param {Object} tokens - The tokens object to be set.\n  * @returns {Promise} - A promise that resolves when the preferences have been set or reset, or rejects with an error if the operation fails.\n  */\n  async setConsentTokens(tokens) {\n    try {\n      let response\n\n      const consentTokens = ConsentTokens.from(tokens)\n\n      if (this.serverMode === SERVER_MODE.LOCAL) {\n        response = await this._storage.setConsentTokens(consentTokens)\n      } else {\n        response = await this._server.postMessage('setConsentTokens', consentTokens)\n      }\n\n      if (response) {\n        this.dispatchEvent(new CustomEvent(EVENT_NAMES.CHANGE, { detail: response, bubbles: true, composed: true }))\n        return response\n      }\n    } catch (error) {\n      console.error('[#setConsentTokens]', error)\n      throw error\n    }\n  }\n\n  /**\n   * Resets the user's preferences by clearing the stored preferences data, either in the local storage or on the remote server, depending on the configured server mode.\n   *\n   * @returns {Promise} - A promise that resolves when the preferences have been reset, or rejects with an error if the reset operation fails.\n   */\n  async resetTokens() {\n    try {\n      if (this.serverMode === SERVER_MODE.LOCAL) {\n        return await this._storage.resetTokens()\n      } else {\n        await this._server.postMessage('resetTokens')\n      }\n    } catch (error) {\n      console.error('[#resetTokens]', error)\n      throw error\n    }\n  }\n}\n\nlet consentClient\n\n/**\n * Creates a new ConsentClient instance and initializes it with the provided options.\n *\n * If a ConsentClient instance already exists, it will add the provided host to the existing instance and return it.\n *\n * @param {Object} options - The options to initialize the ConsentClient with.\n * @returns {Promise<ConsentClient>} - A Promise that resolves to the ConsentClient instance.\n */\nexport default async function createConsentClient(options) {\n  if (consentClient) {\n    consentClient.addHost(options)\n\n    return consentClient\n  }\n\n  consentClient = new ConsentClient()\n  await consentClient.init(options)\n\n  return consentClient\n}"],"names":["ConsentClient","EventTarget","constructor","super","_server","_storage","debugIsOn","debug","this","readyState","hosts","host","reflectEvents","push","arguments","event","dispatchEvent","type","listener","options","EVENT_NAMES","READY","fireReadyListener","addEventListener","serverMode","serverUrl","serverRequestTimeout","SERVER_REQUEST_DEFAULT_TIMEOUT","consentTokens","addHost","SERVER_MODE","LOCAL","stringIsUrl","URL","location","searchParams","set","getServerMode","loggerFactory","REMOTE","serverObject","getIframeServer","document","body","href","callServer","listenMessage","method","data","ConsentTokens","from","CustomEvent","CHANGE","detail","bubbles","composed","error","console","log","postMessage","getConsentStorage","getConsentTokens","undefined","setConsentTokens","tokens","response","resetTokens","readyEvent","consentClient","async","createConsentClient","init"],"mappings":"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"}