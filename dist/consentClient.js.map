{"version":3,"file":"consentClient.js","sources":["../src/components/bib-consent/consentClient.js"],"sourcesContent":["import { callServer } from 'postmessage-promise'\r\nimport { stringIsUrl } from '@/utils/url.js'\r\nimport { loggerFactory } from '@/utils/logger.js'\r\nimport getConsentStorage from './ConsentStorage.js'\r\nimport { ConsentTokens } from './ConsentTokens.js'\r\nimport { getIframeServer, getServerMode } from './utils.js'\r\nimport { EVENT_NAMES, SERVER_MODE, SERVER_REQUEST_DEFAULT_TIMEOUT } from './constants.js'\r\n\r\n/**\r\n * Represents a client for managing user consent tokens, with the ability to interact with a remote server or local storage.\r\n *\r\n * The `ConsentClient` class extends the `EventTarget` class, allowing it to dispatch events related to preference updates.\r\n *\r\n * Key features:\r\n * - Initialization with options for server mode (local or remote), server URL, and event reflection.\r\n * - Ability to add hosts that will receive preference update events.\r\n * - Debugging functionality with configurable debug mode.\r\n * - Methods to set, get, and reset user tokens, with different behavior based on server mode.\r\n *\r\n * @property {string} readyState - The current state of the ConsentClient instance. Can be 'initial', 'connecting' or 'ready'.\r\n */\r\nclass ConsentClient extends EventTarget {\r\n  _server\r\n  _storage\r\n  #debugIsOn = false\r\n  #debug\r\n\r\n  constructor() {\r\n    super()\r\n    this.readyState = 'initial'\r\n    this.hosts = []\r\n  }\r\n\r\n  addHost({ host, reflectEvents }) {\r\n    this.hosts.push({ host, reflectEvents })\r\n  }\r\n\r\n  debug() {\r\n    if (this.#debugIsOn) {\r\n      this.#debug(...arguments)\r\n    }\r\n  }\r\n\r\n  dispatchEvent(event) {\r\n    super.dispatchEvent(event)\r\n    this.hosts.forEach(({ host, reflectEvents }) => reflectEvents && host.dispatchEvent?.(event))\r\n  }\r\n\r\n  /**\r\n   * Adds an event listener to the ConsentClient instance.\r\n   *\r\n   * If the event type is `EVENT_NAMES.READY` and the `readyState` is already `'ready'`, the listener function is called immediately with the current preferences object as the event detail.\r\n   *\r\n   * Otherwise, the event listener is added using the standard `addEventListener` method.\r\n   *\r\n   * @param {string} type - The type of event to listen for.\r\n   * @param {EventListener} listener - The function to call when the event is dispatched.\r\n   * @param {EventListenerOptions} [options] - Options for the event listener.\r\n   */\r\n  addEventListener(type, listener, options) {\r\n    if (type === EVENT_NAMES.READY && this.readyState === 'ready') {\r\n      this.debug('Firing ready event immediately since readyState is already ready')\r\n      this.#fireReadyListener(listener)\r\n      return\r\n    }\r\n\r\n    super.addEventListener(type, listener, options)\r\n  }\r\n\r\n  async #fireReadyListener(listener) {\r\n    const consentTokens = await this.getConsentTokens()\r\n    const readyEvent = new CustomEvent(EVENT_NAMES.READY, { detail: consentTokens })\r\n    this.debug('Firing ready event with preferences: ', consentTokens)\r\n    listener(readyEvent)\r\n  }\r\n\r\n  /**\r\n   * Initializes the ConsentClient instance with the provided options.\r\n   *\r\n   * @param {Object} options - The initialization options.\r\n   * @param {Object} [options.host] - The host object that will receive preference update events.\r\n   * @param {string} [options.serverMode] - The server mode, either 'LOCAL' or 'REMOTE'.\r\n   * @param {string} [options.serverUrl] - The URL of the remote server.\r\n   * @param {number} [options.serverRequestTimeout=SERVER_REQUEST_DEFAULT_TIMEOUT] - The timeout for server requests in milliseconds.\r\n   * @param {boolean} [options.reflectEvents=true] - Whether to reflect preference update events to the host.\r\n   * @returns {Promise<void>} - A promise that resolves when initialization is complete.\r\n   *\r\n   * @event EVENT_NAMES.READY - Dispatched when the initial preferences data is available. The event detail contains the preferences object.\r\n   * @event EVENT_NAMES.UPDATE - Dispatched when the preferences are updated. The event detail contains the updated preferences object.\r\n   */\r\n\r\n  async init({ host, serverMode, serverUrl, serverRequestTimeout = SERVER_REQUEST_DEFAULT_TIMEOUT, reflectEvents = true }) {\r\n    this.serverRequestTimeout = serverRequestTimeout\r\n\r\n    if (host) {\r\n      this.addHost({ host, reflectEvents })\r\n    }\r\n\r\n    this.readyState = 'connecting'\r\n\r\n    if (\r\n      (\r\n        serverMode && serverMode === SERVER_MODE.LOCAL\r\n      )\r\n      ||\r\n      typeof serverUrl === 'undefined'\r\n      ||\r\n      !stringIsUrl(serverUrl)\r\n    ) {\r\n      this.serverMode = SERVER_MODE.LOCAL\r\n    } else {\r\n      this.serverUrl = new URL(serverUrl, location)\r\n\r\n      if (host.debug) {\r\n        this.serverUrl.searchParams.set('debug', '')\r\n      }\r\n\r\n      this.serverMode = await getServerMode(this)\r\n\r\n    }\r\n\r\n    this.#debugIsOn = !!host.debug\r\n\r\n    if (this.#debugIsOn) {\r\n      this.#debug = loggerFactory('consentClient', 'purple')\r\n    }\r\n\r\n    this.debug('init', `server mode: ${this.serverMode}`)\r\n\r\n    let consentTokens\r\n\r\n    if (this.serverMode === SERVER_MODE.REMOTE) {\r\n      const serverObject = getIframeServer(document.body, this.serverUrl.href)\r\n\r\n      try {\r\n        this._server = await callServer(serverObject)\r\n\r\n        this._server.listenMessage((method, data) => {\r\n          this.debug('[remote] server.listenMessage method: ', method, 'data: ', data)\r\n          const consentTokens = ConsentTokens.from(data)\r\n          const event = new CustomEvent(EVENT_NAMES.UPDATE, { detail: consentTokens })\r\n          this.dispatchEvent(event)\r\n        })\r\n      } catch (error) {\r\n        console.error('[callServer] error: ', error)\r\n        throw error\r\n      }\r\n\r\n      consentTokens = ConsentTokens.from(await this._server.postMessage('getConsentTokens'))\r\n      this.debug('[remote] Got response from server: ', consentTokens)\r\n\r\n    } else {\r\n      this._storage = await getConsentStorage()\r\n\r\n      consentTokens = await this._storage.getConsentTokens()\r\n      this.debug('[local] Got response from storage: ', consentTokens)\r\n    }\r\n\r\n    this.debug('[local] consentTokens: ', consentTokens)\r\n\r\n    if (consentTokens !== undefined) {\r\n\r\n      // Dispatch initial data with the ready state.\r\n      this.readyState = 'ready'\r\n\r\n      this.debug('dispatchEvent', EVENT_NAMES.READY, consentTokens)\r\n      this.dispatchEvent(new CustomEvent(EVENT_NAMES.READY, { detail: consentTokens }))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the user's preferences from either the local storage or the remote server, depending on the configured server mode.\r\n   *\r\n   * @returns {Promise<Object>} - A promise that resolves with the user's preferences, or rejects with an error if the operation fails.\r\n   */\r\n  async getConsentTokens() {\r\n    try {\r\n      if (this.serverMode === SERVER_MODE.LOCAL) {\r\n        return await this._storage.getConsentTokens()\r\n      } else {\r\n        return ConsentTokens.from(await this._server.postMessage('getConsentTokens'))\r\n      }\r\n    } catch (error) {\r\n      console.error('[#getConsentTokens]', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n  * Sets the user's tokens in either the local storage or the remote server, depending on the configured server mode.\r\n  *\r\n  * @param {Object} tokens - The tokens object to be set.\r\n  * @returns {Promise} - A promise that resolves when the preferences have been set or reset, or rejects with an error if the operation fails.\r\n  */\r\n  async setConsentTokens(tokens) {\r\n    try {\r\n      let response\r\n\r\n      const consentTokens = ConsentTokens.from(tokens)\r\n\r\n      if (this.serverMode === SERVER_MODE.LOCAL) {\r\n        response = await this._storage.setConsentTokens(consentTokens)\r\n      } else {\r\n        response = await this._server.postMessage('setConsentTokens', consentTokens)\r\n      }\r\n\r\n      if (response) {\r\n        this.dispatchEvent(new CustomEvent(EVENT_NAMES.UPDATE, { detail: response }))\r\n        return response\r\n      }\r\n    } catch (error) {\r\n      console.error('[#setConsentTokens]', error)\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the user's preferences by clearing the stored preferences data, either in the local storage or on the remote server, depending on the configured server mode.\r\n   *\r\n   * @returns {Promise} - A promise that resolves when the preferences have been reset, or rejects with an error if the reset operation fails.\r\n   */\r\n  async resetTokens() {\r\n    try {\r\n      if (this.serverMode === SERVER_MODE.LOCAL) {\r\n        return await this._storage.resetTokens()\r\n      } else {\r\n        await this._server.postMessage('resetTokens')\r\n      }\r\n    } catch (error) {\r\n      console.error('[#resetTokens]', error)\r\n      throw error\r\n    }\r\n  }\r\n}\r\n\r\nlet consentClient\r\n\r\n/**\r\n * Creates a new ConsentClient instance and initializes it with the provided options.\r\n *\r\n * If a ConsentClient instance already exists, it will add the provided host to the existing instance and return it.\r\n *\r\n * @param {Object} options - The options to initialize the ConsentClient with.\r\n * @returns {Promise<ConsentClient>} - A Promise that resolves to the ConsentClient instance.\r\n */\r\nexport default async function createConsentClient(options) {\r\n  if (consentClient) {\r\n    consentClient.addHost(options)\r\n\r\n    return consentClient\r\n  }\r\n\r\n  consentClient = new ConsentClient()\r\n  await consentClient.init(options)\r\n\r\n  return consentClient\r\n}"],"names":["ConsentClient","EventTarget","_server","super","_storage","debugIsOn","debug","this","readyState","hosts","addHost","host","reflectEvents","push","arguments","event","dispatchEvent","forEach","type","listener","options","EVENT_NAMES","READY","fireReadyListener","addEventListener","serverMode","serverUrl","serverRequestTimeout","SERVER_REQUEST_DEFAULT_TIMEOUT","consentTokens","SERVER_MODE","LOCAL","stringIsUrl","URL","location","searchParams","set","getServerMode","loggerFactory","REMOTE","serverObject","getIframeServer","document","body","href","callServer","listenMessage","method","data","ConsentTokens","from","CustomEvent","UPDATE","detail","error","console","postMessage","getConsentStorage","getConsentTokens","tokens","response","setConsentTokens","resetTokens","readyEvent","consentClient","async","createConsentClient","init"],"mappings":"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"}