{"version":3,"file":"bib-consent.js","sources":["../node_modules/@lit/context/development/lib/value-notifier.js","../node_modules/@lit/context/development/lib/controllers/context-provider.js","../src/components/bib-consent/bib-consent.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/**\n * A simple class which stores a value, and triggers registered callbacks when\n * the value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to\n * get behavior like this. But this is a pretty minimal approach that will\n * likely work for a number of use cases.\n */\nexport class ValueNotifier {\n    get value() {\n        return this._value;\n    }\n    set value(v) {\n        this.setValue(v);\n    }\n    setValue(v, force = false) {\n        const update = force || !Object.is(v, this._value);\n        this._value = v;\n        if (update) {\n            this.updateObservers();\n        }\n    }\n    constructor(defaultValue) {\n        this.subscriptions = new Map();\n        this.updateObservers = () => {\n            for (const [callback, { disposer }] of this.subscriptions) {\n                callback(this._value, disposer);\n            }\n        };\n        if (defaultValue !== undefined) {\n            this.value = defaultValue;\n        }\n    }\n    addCallback(callback, consumerHost, subscribe) {\n        if (!subscribe) {\n            // just call the callback once and we're done\n            callback(this.value);\n            return;\n        }\n        if (!this.subscriptions.has(callback)) {\n            this.subscriptions.set(callback, {\n                disposer: () => {\n                    this.subscriptions.delete(callback);\n                },\n                consumerHost,\n            });\n        }\n        const { disposer } = this.subscriptions.get(callback);\n        callback(this.value, disposer);\n    }\n    clearCallbacks() {\n        this.subscriptions.clear();\n    }\n}\n//# sourceMappingURL=value-notifier.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { ContextRequestEvent } from '../context-request-event.js';\nimport { ValueNotifier } from '../value-notifier.js';\nexport class ContextProviderEvent extends Event {\n    /**\n     *\n     * @param context the context which this provider can provide\n     */\n    constructor(context) {\n        super('context-provider', { bubbles: true, composed: true });\n        this.context = context;\n    }\n}\n/**\n * A ReactiveController which adds context provider behavior to a\n * custom element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n *\n * The controller may also be attached to any HTML element in which case it's\n * up to the user to call hostConnected() when attached to the DOM. This is\n * done automatically for any custom elements implementing\n * ReactiveControllerHost.\n */\nexport class ContextProvider extends ValueNotifier {\n    constructor(host, contextOrOptions, initialValue) {\n        super(contextOrOptions.context !== undefined\n            ? contextOrOptions.initialValue\n            : initialValue);\n        this.onContextRequest = (ev) => {\n            // Only call the callback if the context matches.\n            // Also, in case an element is a consumer AND a provider\n            // of the same context, we want to avoid the element to self-register.\n            // The check on composedPath (as opposed to ev.target) is to cover cases\n            // where the consumer is in the shadowDom of the provider (in which case,\n            // event.target === this.host because of event retargeting).\n            const consumerHost = ev.composedPath()[0];\n            if (ev.context !== this.context || consumerHost === this.host) {\n                return;\n            }\n            ev.stopPropagation();\n            this.addCallback(ev.callback, consumerHost, ev.subscribe);\n        };\n        /**\n         * When we get a provider request event, that means a child of this element\n         * has just woken up. If it's a provider of our context, then we may need to\n         * re-parent our subscriptions, because is a more specific provider than us\n         * for its subtree.\n         */\n        this.onProviderRequest = (ev) => {\n            // Ignore events when the context doesn't match.\n            // Also, in case an element is a consumer AND a provider\n            // of the same context it shouldn't provide to itself.\n            // We use composedPath (as opposed to ev.target) to cover cases\n            // where the consumer is in the shadowDom of the provider (in which case,\n            // event.target === this.host because of event retargeting).\n            const childProviderHost = ev.composedPath()[0];\n            if (ev.context !== this.context || childProviderHost === this.host) {\n                return;\n            }\n            // Re-parent all of our subscriptions in case this new child provider\n            // should take them over.\n            const seen = new Set();\n            for (const [callback, { consumerHost }] of this.subscriptions) {\n                // Prevent infinite loops in the case where a one host element\n                // is providing the same context multiple times.\n                //\n                // While normally it's a no-op to attempt to re-parent a subscription\n                // that already has its proper parent, in the case where there's more\n                // than one ValueProvider for the same context on the same hostElement,\n                // they will each call the consumer, and since they will each have their\n                // own dispose function, a well behaved consumer will notice the change\n                // in dispose function and call their old one.\n                //\n                // This will cause the subscriptions to thrash, but worse, without this\n                // set check here, we can end up in an infinite loop, as we add and remove\n                // the same subscriptions onto the end of the map over and over.\n                if (seen.has(callback)) {\n                    continue;\n                }\n                seen.add(callback);\n                consumerHost.dispatchEvent(new ContextRequestEvent(this.context, callback, true));\n            }\n            ev.stopPropagation();\n        };\n        this.host = host;\n        if (contextOrOptions.context !== undefined) {\n            this.context = contextOrOptions.context;\n        }\n        else {\n            this.context = contextOrOptions;\n        }\n        this.attachListeners();\n        this.host.addController?.(this);\n    }\n    attachListeners() {\n        this.host.addEventListener('context-request', this.onContextRequest);\n        this.host.addEventListener('context-provider', this.onProviderRequest);\n    }\n    hostConnected() {\n        // emit an event to signal a provider is available for this context\n        this.host.dispatchEvent(new ContextProviderEvent(this.context));\n    }\n}\n//# sourceMappingURL=context-provider.js.map","import { html, LitElement } from 'lit'\nimport { createRef, ref } from 'lit/directives/ref.js'\nimport { ContextProvider, ContextConsumer } from '@lit/context'\nimport '@auroratide/toggle-switch/lib/define.js'\nimport { loggerFactory } from '@/utils/logger.js'\nimport { addToGlobalBib } from '@/utils/bib.js'\nimport '../bib-button/bib-button-close.js'\nimport './bib-consent-consent-dialog.js'\nimport './bib-consent-preferences-dialog.js'\nimport createConsentClient from './consentClient.js'\nimport { consentContext } from './consent-context.js'\nimport { EVENT_NAMES, SERVER_MODE, SERVER_REQUEST_DEFAULT_TIMEOUT, CONSENT_STATES } from './constants.js'\nimport { ConsentTokens } from './ConsentTokens.js'\n\nconst debug = loggerFactory('bib-consent', '#cd5300')\n\n/**\n * The `BibConsent` class is a custom web component that provides a user interface for managing consent preferences.\n *\n * It includes the following functionality:\n * - Fetching and displaying the user's consent preferences from a server\n * - Allowing the user to update their consent preferences\n * - Saving the updated consent preferences to the server\n * - Providing a consent dialog and a preferences dialog for the user to interact with\n *\n * The component can be configured with the following properties:\n * - `serverUrl`: the URL of the server where the consent preferences are stored\n * - `serverRequestTimeout`: the timeout for requests to the server\n * - `[SERVER_MODE.LOCAL]`: a boolean indicating whether the component is running in local mode\n * - `debug`: a boolean indicating whether debug logging should be enabled\n * - `open`: a boolean indicating whether the consent dialog or preferences dialog is currently open\n *\n * The component uses the `@lit/context` library to manage the consent preferences as a shared context, and the `createConsentClient` function to interact with the server.\n */\n/**\n * The `BibConsent` class is a custom web component that provides a user interface for managing consent preferences.\n *\n * It includes the following functionality:\n * - Fetching and displaying the user's consent preferences from a server\n * - Allowing the user to update their consent preferences\n * - Saving the updated consent preferences to the server\n * - Providing a consent dialog and a preferences dialog for the user to interact with\n *\n * The component can be configured with the following properties:\n * - `serverUrl`: the URL of the server where the consent preferences are stored\n * - `serverRequestTimeout`: the timeout for requests to the server\n * - `[SERVER_MODE.LOCAL]`: a boolean indicating whether the component is running in local mode\n * - `debug`: a boolean indicating whether debug logging should be enabled\n * - `open`: a boolean indicating whether the consent dialog or preferences dialog is currently open\n *\n * The component uses the `@lit/context` library to manage the consent preferences as a shared context, and the `createConsentClient` function to interact with the server.\n */\nexport class BibConsent extends LitElement {\n  static properties = {\n    serverUrl: {\n      type: String,\n      attribute: 'server-url',\n      reflect: true\n    },\n    serverRequestTimeout: {\n      type: Number,\n      attribute: 'server-request-timeout',\n      reflect: true\n    },\n    [SERVER_MODE.LOCAL]: {\n      type: Boolean\n    },\n    state: {\n      type: String\n    },\n    debug: {\n      type: Boolean,\n      reflect: true\n    },\n    open: {\n      type: Boolean,\n      reflect: true\n    },\n  }\n\n  _consentClient\n  #consentTokens\n  #consentProvider\n  #consentConsumer\n  #state = CONSENT_STATES.INDETERMINATE\n  #consentDialogRef\n  #preferencesDialogRef\n\n  /**\n   * Initializes the `BibConsent` component, setting up the necessary state and references.\n   * \n   * The constructor performs the following tasks:\n   * - Calls the parent class constructor (`super()`)\n   * - Initializes the `open` property to `false`, indicating that no dialog is currently open\n   * - Sets the `currentDialog` property to `null`, as no dialog is currently open\n   * - Creates references to the consent dialog and preferences dialog using `createRef()`\n   * - Creates a `ContextProvider` instance for the consent context, with the component instance as the host and an initial value of `null`\n   * - Creates a `ContextConsumer` instance for the consent context, with the component instance as the host and the `savePreferences` method as the callback\n   */\n  constructor() {\n    super()\n    this.open = false\n    this.currentDialog = null\n    this.#consentDialogRef = createRef()\n    this.#preferencesDialogRef = createRef()\n    this.#consentProvider = new ContextProvider(this, { context: consentContext, initialValue: new ConsentTokens() })\n    this.#consentConsumer = new ContextConsumer(this, { context: consentContext, callback: this.savePreferences })\n  }\n\n  /**\n   * Gets the current state of the BibConsent component.\n   * The state is determined by the user's input. Initially `indeterminate`, it turns `determinate` when the user has indicated their consent preferences.\n   * @readonly\n   * @returns {import('./constants.js').consentStateTypes} The current state of the BibConsent component, which can be one of the following values:\n   * - `indeterminate`: The user has not yet indicated their consent preferences.\n   * - `determinate`: The user has made their consent preferences.\n   */\n  get state() {\n    return this.#state\n  }\n\n  /**\n   * Gets the user's consent tokens.\n   * @readonly\n   * @returns {import('./ConsentTokens.js').ConsentTokens} The user's consent tokens.\n   */\n  get consentTokens() {\n    return this.#consentConsumer.value\n  }\n\n  /**\n   * Initializes the `BibConsent` component, sets up the necessary state and references, and handles events related to the consent client.\n   * \n   * The `connectedCallback` method performs the following tasks:\n   * - Calls the parent class's `connectedCallback` method\n   * - Sets the `debug` property to `false` if it is not already defined\n   * - Sets the `serverUrl` property to `'https://bib.umontreal.ca/consent/server'` if it is not already defined\n   * - Sets the `serverRequestTimeout` property to `SERVER_REQUEST_DEFAULT_TIMEOUT` if it is not already defined\n   * - Creates a `ConsentClient` instance and assigns it to the `_consentClient` property\n   * - Adds event listeners for the `EVENT_NAMES.READY` and `EVENT_NAMES.UPDATE` events on the `_consentClient` instance\n   * - Adds an event listener for the `context-request` event on the component's shadow root, which responds with the current tokens\n   */\n  async connectedCallback() {\n    super.connectedCallback()\n\n    this.debug = this.debug || false\n    this.serverUrl = this.serverUrl || 'https://bib.umontreal.ca/consent/server'\n    this.serverRequestTimeout = this.serverRequestTimeout || SERVER_REQUEST_DEFAULT_TIMEOUT\n    this._consentClient = await createConsentClient({ host: this, serverUrl: this.serverUrl, serverRequestTimeout: this.serverRequestTimeout, reflectEvents: true })\n\n    this._consentClient.addEventListener(EVENT_NAMES.READY, event => {\n      const { detail } = event\n\n      this.#debug(EVENT_NAMES.READY, 'event: ', event)\n\n      if (detail.state() === CONSENT_STATES.DETERMINATE) {\n        this.#setValue(detail)\n      } else {\n        this.#show('consent')\n      }\n    })\n  }\n\n  #setValue(value) {\n    this.#consentProvider.setValue(value)\n    this.#state = this.#consentProvider.value.state()\n  }\n\n  #debug() {\n    if (this.debug) {\n      debug(...arguments)\n    }\n  }\n\n  #close(emit = true) {\n    this.open = false\n    this.currentDialog?.close(emit)\n    this.currentDialog = null\n  }\n\n  /**\n   * Closes the current dialog, if any, and sets the `open` property to `false`.\n   */\n  close() {\n    this.#close()\n  }\n\n  #show(panel = 'consent') {\n\n    if (typeof panel !== 'string' && !['consent', 'preferences'].includes(panel)) {\n      throw new TypeError(`The panel argument must be a string of either values 'consent' or 'preferences'. `, panel)\n    }\n\n    this.open = true\n\n    if (this.currentDialog) {\n      this.#debug('[#show] this.currentDialog', this.currentDialog)\n      this.currentDialog.close()\n    }\n\n    this.#debug('[show]', this.#consentDialogRef.value)\n    this.#debug('[show]', this.#preferencesDialogRef.value)\n    this.currentDialog = panel === 'consent' ? this.#consentDialogRef.value : this.#preferencesDialogRef.value\n    this.currentDialog.show()\n  }\n\n  /**\n   * Shows the consent dialog.\n   */\n  show() {\n    this.#show('consent')\n  }\n\n  /**\n   * Shows the preferences dialog.\n   */\n  showPreferences() {\n    this.#show('preferences')\n  }\n\n  /**\n   * Retrieves the user's consent tokens from the server.\n   *\n   * @returns {Promise<Object>} - A promise that resolves to the user's consent tokens.\n   */\n  async getTokens() {\n    this.#consentTokens = await this._consentClient.getConsentTokens()\n    return this.#consentTokens\n  }\n\n  /**\n   * Saves the user's consent tokens to the server.\n   *\n   * @param {Object} preferences - The user's consent preferences.\n   * @returns {Promise<boolean>} - A promise that resolves to `true` if the preferences were saved successfully, or `false` if there was an error.\n   */\n\n  async saveTokens(tokens) {\n    this.#debug('[save] tokens: ', tokens)\n    const consentTokens = ConsentTokens.from(tokens)\n    try {\n      await this._consentClient.setConsentTokens(consentTokens)\n      this.#setValue(consentTokens)\n      return true\n    } catch (error) {\n      console.error('[savePreferences] error: ', error)\n      throw error\n    }\n  }\n\n  /**\n   * Resets the user's consent preferences to their default values.\n   *\n   * @returns {Promise<Object>} - A promise that resolves to the user's reset consent preferences.\n   */\n  async resetTokens() {\n    this.#consentTokens = await this._consentClient.resetTokens()\n    return this.#consentTokens\n  }\n\n  async #handleUpdateEvent(event) {\n    this.#debug('[#handleUpdateEvent]', event)\n    const success = await this.saveTokens(event.detail)\n    this.#debug('[#handleUpdateEvent] success: ', success)\n    if (!success) {\n      // TODO: show error message\n      return\n    }\n    this.dispatchEvent(new CustomEvent(EVENT_NAMES.UPDATE, { detail: this.consentTokens }))\n    this.#close()\n  }\n\n  #handleCloseEvent(event) {\n    event.stopPropagation()\n    this.#close(false)\n  }\n\n  render() {\n    return html`\n        <bib-consent-consent-dialog @update=\"${this.#handleUpdateEvent}\" @show-preferences=\"${() => this.#show('preferences')}\" ${ref(this.#consentDialogRef)} @close=\"${this.#handleCloseEvent}\"></bib-consent-consent-dialog>\n        <bib-consent-preferences-dialog @update=\"${this.#handleUpdateEvent}\" ${ref(this.#preferencesDialogRef)} @close=\"${this.#handleCloseEvent}\"></bib-consent-preferences-dialog>\n    `\n  }\n}\n\nif (!window.customElements.get('bib-consent')) {\n  window.customElements.define('bib-consent', BibConsent)\n}\n\naddToGlobalBib('consent', {})"],"names":["ValueNotifier","this","_value","value","v","setValue","force","update","Object","is","updateObservers","defaultValue","subscriptions","Map","callback","disposer","consumerHost","subscribe","has","set","delete","get","clearCallbacks","clear","ContextProviderEvent","Event","context","super","bubbles","composed","ContextProvider","host","contextOrOptions","initialValue","onContextRequest","ev","composedPath","stopPropagation","addCallback","onProviderRequest","childProviderHost","seen","Set","add","dispatchEvent","ContextRequestEvent","attachListeners","addController","addEventListener","debug","loggerFactory","BibConsent","LitElement","_consentClient","consentTokens","consentProvider","consentConsumer","state","CONSENT_STATES","INDETERMINATE","consentDialogRef","preferencesDialogRef","open","currentDialog","createRef","consentContext","ConsentTokens","ContextConsumer","savePreferences","connectedCallback","serverUrl","serverRequestTimeout","SERVER_REQUEST_DEFAULT_TIMEOUT","createConsentClient","reflectEvents","EVENT_NAMES","READY","event","detail","DETERMINATE","show","close","getConsentTokens","tokens","from","setConsentTokens","error","console","resetTokens","html","handleUpdateEvent","ref","arguments","emit","panel","includes","TypeError","success","saveTokens","CustomEvent","UPDATE","handleCloseEvent","static","type","String","attribute","reflect","Number","SERVER_MODE","LOCAL","Boolean","window","customElements","define","addToGlobalBib"],"mappings":"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","x_google_ignoreList":[0,1]}