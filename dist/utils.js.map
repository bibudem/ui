{"version":3,"file":"utils.js","sources":["../src/components/bib-consent/utils.js"],"sourcesContent":["import { utils as postmessageUtils } from 'postmessage-promise'\nimport { hasBooleanParam } from '@/utils/url.js'\nimport { PREFIX, SERVER_MODE, SERVER_REQUEST_DEFAULT_TIMEOUT } from './constants.js'\n\n/**\n * Creates a prefixed key name for the BIB consent module.\n * @param {string} key - The key to be prefixed.\n * @returns {string} - The prefixed key name.\n */\nexport function getKeyName(key) {\n  return `${PREFIX}-${key}`\n}\n\n/**\n * Gets an iframe server for a given target URL.\n * @param {HTMLElement} [container=document.body] - The container element for the iframe.\n * @param {string} targetUrl - The target URL for the iframe.\n * @returns {object} - An object containing the iframe server, origin, and the iframe element.\n */\nexport function getIframeServer(\n  container,\n  targetUrl,\n) {\n  const root = typeof container !== 'undefined' ? container : document.body\n  const origin = postmessageUtils.resolveOrigin(targetUrl)\n  const iframeId = getKeyName('iframe')\n  let iframe\n  if (document.querySelector(`#${iframeId}`)) {\n    iframe = document.querySelector(`#${iframeId}`)\n  } else {\n    iframe = document.createElement('iframe')\n    iframe.id = iframeId\n\n    const isDebugOn = hasBooleanParam(targetUrl, 'debug')\n\n    if (!isDebugOn) {\n      iframe.ariaHidden = true\n      iframe.tabIndex = -1\n      iframe.hidden = true\n      iframe.style.setProperty('display', 'none')\n    } else {\n      iframe.style.cssText = 'width: 100%; height: 100%; border: 0;'\n    }\n\n    root.appendChild(iframe)\n    iframe.src = targetUrl\n  }\n\n  const iframeWindow = iframe.contentWindow || iframe.contentDocument.parentWindow\n\n  return {\n    server: iframeWindow,\n    origin,\n    iframe,\n  }\n}\n\n/**\n * Checks the server mode for a given client.\n * \n * If the client has no server URL, the function returns `SERVER_MODE.LOCAL`.\n * Otherwise, it checks if the server page exists by making a fetch request to the server URL.\n * If the request is successful (response.ok), the function returns `SERVER_MODE.REMOTE`.\n * If the request times out or fails, the function throws an error with the appropriate message.\n *\n * @param {object} client - The client object containing the server URL.\n * @param {number} [timeout=SERVER_REQUEST_DEFAULT_TIMEOUT] - The timeout in milliseconds for the server request.\n * @returns {string} - The server mode, either `SERVER_MODE.LOCAL` or `SERVER_MODE.REMOTE`.\n * @throws {Error} - If the server page cannot be located or the request fails.\n */\nexport async function getServerMode(client) {\n\n  const serverUrl = client.serverUrl\n  const timeout = client.serverRequestTimeout || SERVER_REQUEST_DEFAULT_TIMEOUT\n\n  if (!serverUrl) {\n    return SERVER_MODE.LOCAL\n  }\n\n  // Check if server page exists\n  const controller = new AbortController()\n  let response\n  let timeoutHandle\n\n  try {\n    timeoutHandle = setTimeout(() => {\n      console.warn(`Request timed out after ${timeout}ms. Aborting request...`)\n      controller.abort()\n    }, timeout)\n    response = await fetch(serverUrl, { signal: controller.signal })\n\n    if (response.ok) {\n      return SERVER_MODE.REMOTE\n    }\n  } catch (error) {\n    console.error(error)\n\n    if (controller.signal.aborted) {\n      // throw new Error(`Unable to locate server page. The request timed out after ${timeout}ms. url: ${serverUrl.href}`)\n      console.error(`Unable to locate server page. The request timed out after ${timeout}ms. url: ${serverUrl.href}`)\n      return SERVER_MODE.LOCAL\n    }\n\n    // throw new Error(`Unable to locate server page : ${serverUrl.href}.`, error)\n    console.error(`Unable to locate server page : ${serverUrl.href}.`, error)\n    return SERVER_MODE.LOCAL\n  } finally {\n    clearTimeout(timeoutHandle)\n  }\n\n  throw new Error(`Unable to locate server page. The request failed with status code ${response.status}. url: ${serverUrl.href}`)\n}"],"names":["getKeyName","key","PREFIX","getIframeServer","container","targetUrl","root","document","body","origin","postmessageUtils","resolveOrigin","iframeId","iframe","querySelector","createElement","id","hasBooleanParam","style","cssText","ariaHidden","tabIndex","hidden","setProperty","appendChild","src","server","contentWindow","contentDocument","parentWindow","async","getServerMode","client","serverUrl","timeout","serverRequestTimeout","SERVER_REQUEST_DEFAULT_TIMEOUT","SERVER_MODE","LOCAL","controller","AbortController","response","timeoutHandle","setTimeout","console","warn","abort","fetch","signal","ok","REMOTE","error","aborted","href","clearTimeout","Error","status"],"mappings":";;AASO,SAASA,EAAWC,IAAAA;AACzB,SAAO,GAAGC,KAAUD,EACtB;AAAA;AAQO,SAASE,EACdC,IACAC;AAEA,QAAMC,KAAAA,WAAcF,KAA4BA,KAAYG,SAASC,MAC/DC,KAASC,EAAiBC,cAAcN,KACxCO,KAAWZ,EAAW;AAC5B,MAAIa;AAwBJ,SAvBIN,SAASO,cAAc,IAAIF,EAC7BC,EAAAA,IAAAA,IAASN,SAASO,cAAc,IAAIF,EAEpCC,EAAAA,KAAAA,IAASN,SAASQ,cAAc,QAAA,GAChCF,EAAOG,KAAKJ,IAEMK,EAAgBZ,IAAW,OAAA,IAQ3CQ,EAAOK,MAAMC,UAAU,2CALvBN,EAAOO,mBACPP,EAAOQ,eACPR,EAAOS,SAAS,MAChBT,EAAOK,MAAMK,YAAY,WAAW,MAKtCjB,IAAAA,GAAKkB,YAAYX,CACjBA,GAAAA,EAAOY,MAAMpB,KAKR,EACLqB,QAHmBb,EAAOc,iBAAiBd,EAAOe,gBAAgBC,cAIlEpB,YACAI,QAEJ,EAAA;AAAA;AAeOiB,eAAeC,EAAcC;AAElC,QAAMC,KAAYD,GAAOC,WACnBC,KAAUF,GAAOG,wBAAwBC;AAE/C,MAAKH,CAAAA,GACH,QAAOI,EAAYC;AAIrB,QAAMC,KAAa,IAAIC;AACvB,MAAIC,IACAC;AAEJ,MAAA;AAOE,QANAA,KAAgBC,WAAW;AACzBC,cAAQC,KAAK,2BAA2BX,EACxCK,yBAAAA,GAAAA,GAAWO;IAAO,GACjBZ,EAAAA,GACHO,WAAiBM,MAAMd,IAAW,EAAEe,QAAQT,GAAWS,WAEnDP,GAASQ,GACX,QAAOZ,EAAYa;AAAAA,EAEtB,SAAQC;AAGP,WAFAP,QAAQO,MAAMA,EAEVZ,GAAAA,GAAWS,OAAOI,WAEpBR,QAAQO,MAAM,6DAA6DjB,EAAAA,YAAmBD,GAAUoB,IACjGhB,EAAAA,GAAAA,EAAYC,UAIrBM,QAAQO,MAAM,kCAAkClB,GAAUoB,SAASF,EAC5Dd,GAAAA,EAAYC;AAAAA,EACvB,UAAY;AACRgB,iBAAaZ,EACd;AAAA,EAAA;AAED,QAAM,IAAIa,MAAM,qEAAqEd,GAASe,MAAAA,UAAgBvB,GAAUoB,IAC1H,EAAA;AAAA;"}