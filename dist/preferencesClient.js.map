{"version":3,"file":"preferencesClient.js","sources":["../src/components/bib-consent/preferencesClient.js"],"sourcesContent":["import { callServer } from 'postmessage-promise'\nimport { stringIsUrl } from '@/utils/url.js'\nimport { loggerFactory } from '@/utils/logger.js'\nimport PreferenceStorage from './PreferenceStorage.js'\nimport { getIframeServer, getServerMode } from './utils.js'\nimport { EVENT_NAMES, SERVER_MODE, SERVER_REQUEST_DEFAULT_TIMEOUT } from './constants.js'\n\n/**\n * Represents a client for managing user preferences, with the ability to interact with a remote server or local storage.\n *\n * The `PreferencesClient` class extends the `EventTarget` class, allowing it to dispatch events related to preference updates.\n *\n * Key features:\n * - Initialization with options for server mode (local or remote), server URL, and event reflection.\n * - Ability to add hosts that will receive preference update events.\n * - Debugging functionality with configurable debug mode.\n * - Methods to set, get, and reset user preferences, with different behavior based on server mode.\n *\n * @property {string} readyState - The current state of the PreferencesClient instance. Can be 'initial', 'connecting' or 'ready'.\n */\nclass PreferencesClient extends EventTarget {\n  _server\n  _storage\n  #preferences\n  #debugIsOn = false\n  #debug\n\n  constructor() {\n    super()\n    this.readyState = 'initial'\n    this.hosts = []\n  }\n\n  addHost({ host, reflectEvents }) {\n    this.hosts.push({ host, reflectEvents })\n  }\n\n  debug() {\n    if (this.#debugIsOn) {\n      this.#debug(...arguments)\n    }\n  }\n\n  dispatchEvent(event) {\n    super.dispatchEvent(event)\n    this.hosts.forEach(({ host, reflectEvents }) => reflectEvents && host.dispatchEvent?.(event))\n  }\n\n  /**\n   * Adds an event listener to the PreferencesClient instance.\n   *\n   * If the event type is `EVENT_NAMES.READY` and the `readyState` is already `'ready'`, the listener function is called immediately with the current preferences object as the event detail.\n   *\n   * Otherwise, the event listener is added using the standard `addEventListener` method.\n   *\n   * @param {string} type - The type of event to listen for.\n   * @param {EventListener} listener - The function to call when the event is dispatched.\n   * @param {EventListenerOptions} [options] - Options for the event listener.\n   */\n  addEventListener(type, listener, options) {\n    if (type === EVENT_NAMES.READY && this.readyState === 'ready') {\n      this.#debug('Firing ready event immediately since readyState is already ready')\n      this.#fireReadyListener(listener)\n      return\n    }\n\n    super.addEventListener(type, listener, options)\n  }\n\n  async #fireReadyListener(listener) {\n    const preferences = await this.getPreferences()\n    const readyEvent = new CustomEvent(EVENT_NAMES.READY, { detail: preferences })\n    this.#debug('Firing ready event with preferences: ', preferences)\n    listener(readyEvent)\n  }\n\n  /**\n   * Initializes the PreferencesClient instance with the provided options.\n   *\n   * @param {Object} options - The initialization options.\n   * @param {Object} [options.host] - The host object that will receive preference update events.\n   * @param {string} [options.serverMode] - The server mode, either 'LOCAL' or 'REMOTE'.\n   * @param {string} [options.serverUrl] - The URL of the remote server.\n   * @param {number} [options.serverRequestTimeout=SERVER_REQUEST_DEFAULT_TIMEOUT] - The timeout for server requests in milliseconds.\n   * @param {boolean} [options.reflectEvents=true] - Whether to reflect preference update events to the host.\n   * @returns {Promise<void>} - A promise that resolves when initialization is complete.\n   *\n   * @event EVENT_NAMES.READY - Dispatched when the initial preferences data is available. The event detail contains the preferences object.\n   * @event EVENT_NAMES.UPDATE - Dispatched when the preferences are updated. The event detail contains the updated preferences object.\n   */\n\n  async init({ host, serverMode, serverUrl, serverRequestTimeout = SERVER_REQUEST_DEFAULT_TIMEOUT, reflectEvents = true }) {\n    this.readyState = 'connecting'\n    this.serverRequestTimeout = serverRequestTimeout\n\n    if (host) {\n      this.addHost({ host, reflectEvents })\n    }\n\n    if (\n      (\n        serverMode && serverMode === SERVER_MODE.LOCAL\n      )\n      ||\n      typeof serverUrl === 'undefined'\n      ||\n      !stringIsUrl(serverUrl)\n    ) {\n      this.serverMode = SERVER_MODE.LOCAL\n    } else {\n      this.serverUrl = new URL(serverUrl, location)\n\n      if (host.debug) {\n        this.serverUrl.searchParams.set('debug', '')\n      }\n\n      this.serverMode = await getServerMode(this)\n\n    }\n\n    this.#debugIsOn = Reflect.has(host, 'debug')\n\n    if (this.#debugIsOn) {\n      this.#debug = loggerFactory('preferencesClient', 'purple')\n    }\n\n    this.debug('init', `server mode: ${this.serverMode}`)\n\n    let preferences\n\n    if (this.serverMode === SERVER_MODE.REMOTE) {\n      const serverObject = getIframeServer(document.body, this.serverUrl.href)\n\n      this.#debug('[remote] callServer serverObject: ', serverObject)\n\n      this._server = await callServer(serverObject)\n        .catch(error => {\n          console.error('[callServer] error: ', error)\n          throw error\n        })\n\n      this._server.listenMessage((method, detail) => {\n        this.#debug('[remote] server.listenMessage method: ', method, 'detail: ', detail)\n        const event = new CustomEvent(EVENT_NAMES.UPDATE, { detail })\n        this.dispatchEvent(event)\n      })\n\n      preferences = await this._server.postMessage('getPreferences')\n      this.#debug('[remote] Got response from server: ', preferences)\n\n    } else {\n      this._storage = new PreferenceStorage()\n\n      await this._storage.init()\n\n      preferences = await this._storage.getPreferences()\n      this.#debug('[local] Got response from storage: ', preferences)\n    }\n\n    this.#debug('[local] preferences: ', preferences)\n\n    if (preferences !== undefined) {\n\n      // Dispatch initial data with the ready state.\n      this.readyState = 'ready'\n      this.#preferences = preferences\n\n      this.#debug('dispatchEvent', EVENT_NAMES.READY, preferences)\n      this.dispatchEvent(new CustomEvent(EVENT_NAMES.READY, { detail: preferences }))\n    }\n  }\n\n  /**\n   * Gets the user's preferences from either the local storage or the remote server, depending on the configured server mode.\n   *\n   * @returns {Promise<Object>} - A promise that resolves with the user's preferences, or rejects with an error if the operation fails.\n   */\n  async getPreferences() {\n    try {\n      if (this.serverMode === SERVER_MODE.LOCAL) {\n        return await this._storage.getPreferences()\n      } else {\n        return await this._server.postMessage('getPreferences')\n      }\n    } catch (error) {\n      console.error('[#getPreferences]', error)\n      throw error\n    }\n  }\n\n  /**\n  * Sets the user's preferences in either the local storage or the remote server, depending on the configured server mode.\n  *\n  * @param {Object|null} preferences - The preferences object to be set. If null, it will reset the user's preferences.\n  * @returns {Promise} - A promise that resolves when the preferences have been set or reset, or rejects with an error if the operation fails.\n  */\n  async setPreferences(preferences) {\n    try {\n      let response\n\n      // When there is no preferences object, this is a reset of the user's preferences, so set it to null.\n      if (typeof preferences === 'undefined') {\n        preferences = null\n      }\n\n      if (this.serverMode === SERVER_MODE.LOCAL) {\n        response = await this._storage.setPreferences(preferences)\n      } else {\n        response = await this._server.postMessage('setPreferences', preferences)\n      }\n\n      if (response) {\n        this.dispatchEvent(new CustomEvent(EVENT_NAMES.UPDATE, { detail: response }))\n        return response\n      }\n    } catch (error) {\n      console.error('[#setPreferences]', error)\n      throw error\n    }\n  }\n\n  /**\n   * Resets the user's preferences by clearing the stored preferences data, either in the local storage or on the remote server, depending on the configured server mode.\n   *\n   * @returns {Promise} - A promise that resolves when the preferences have been reset, or rejects with an error if the reset operation fails.\n   */\n  async resetPreferences() {\n    try {\n      if (this.serverMode === SERVER_MODE.LOCAL) {\n        return await this._storage.resetPreferences()\n      } else {\n        await this._server.postMessage('resetPreferences')\n      }\n    } catch (error) {\n      console.error('[#resetPreferences]', error)\n      throw error\n    }\n  }\n}\n\nlet preferencesClient\n\n/**\n * Creates a new PreferencesClient instance and initializes it with the provided options.\n *\n * If a PreferencesClient instance already exists, it will add the provided host to the existing instance and return it.\n *\n * @param {Object} options - The options to initialize the PreferencesClient with.\n * @returns {Promise<PreferencesClient>} - A Promise that resolves to the PreferencesClient instance.\n */\nexport default async function createPreferencesClient(options) {\n  if (preferencesClient) {\n    preferencesClient.addHost(options)\n\n    return preferencesClient\n  }\n\n  preferencesClient = new PreferencesClient()\n  await preferencesClient.init(options)\n\n  return preferencesClient\n}"],"names":["PreferencesClient","EventTarget","constructor","super","this","_server","_storage","preferences","debugIsOn","debug","readyState","hosts","host","reflectEvents","push","t","arguments","event","dispatchEvent","forEach","type","listener","options","EVENT_NAMES","READY","addEventListener","serverMode","serverUrl","serverRequestTimeout","SERVER_REQUEST_DEFAULT_TIMEOUT","addHost","SERVER_MODE","LOCAL","stringIsUrl","URL","location","searchParams","set","getServerMode","Reflect","has","loggerFactory","REMOTE","serverObject","getIframeServer","document","body","href","callServer","catch","error","console","listenMessage","method","detail","CustomEvent","UPDATE","postMessage","PreferenceStorage","init","getPreferences","setPreferences","response","resetPreferences","fireReadyListener","readyEvent","preferencesClient","async","createPreferencesClient"],"mappings":"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"}