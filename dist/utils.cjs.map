{"version":3,"file":"utils.cjs","sources":["../src/components/bib-consent/utils.js"],"sourcesContent":["import { utils as postmessageUtils } from 'postmessage-promise'\r\nimport { hasBooleanParam } from '@/utils/url.js'\r\nimport { PREFIX, SERVER_MODE, SERVER_REQUEST_DEFAULT_TIMEOUT } from './constants.js'\r\n\r\n/**\r\n * Creates a prefixed key name for the BIB consent module.\r\n * @param {string} key - The key to be prefixed.\r\n * @returns {string} - The prefixed key name.\r\n */\r\nexport function getKeyName(key) {\r\n  return `${PREFIX}-${key}`\r\n}\r\n\r\n/**\r\n * Gets an iframe server for a given target URL.\r\n * @param {HTMLElement} [container=document.body] - The container element for the iframe.\r\n * @param {string} targetUrl - The target URL for the iframe.\r\n * @returns {object} - An object containing the iframe server, origin, and the iframe element.\r\n */\r\nexport function getIframeServer(\r\n  container,\r\n  targetUrl,\r\n) {\r\n  const root = typeof container !== 'undefined' ? container : document.body\r\n  const origin = postmessageUtils.resolveOrigin(targetUrl)\r\n  const iframeId = getKeyName('iframe')\r\n  let iframe\r\n  if (document.querySelector(`#${iframeId}`)) {\r\n    iframe = document.querySelector(`#${iframeId}`)\r\n  } else {\r\n    iframe = document.createElement('iframe')\r\n    iframe.id = iframeId\r\n\r\n    const isDebugOn = hasBooleanParam(targetUrl, 'debug')\r\n\r\n    if (!isDebugOn) {\r\n      iframe.ariaHidden = true\r\n      iframe.tabIndex = -1\r\n      iframe.hidden = true\r\n      iframe.style.setProperty('display', 'none')\r\n    } else {\r\n      iframe.style.cssText = 'width: 100%; height: 100%; border: 0;'\r\n    }\r\n\r\n    root.appendChild(iframe)\r\n    iframe.src = targetUrl\r\n  }\r\n\r\n  const iframeWindow = iframe.contentWindow || iframe.contentDocument.parentWindow\r\n\r\n  return {\r\n    server: iframeWindow,\r\n    origin,\r\n    iframe,\r\n  }\r\n}\r\n\r\n/**\r\n * Checks the server mode for a given client.\r\n * \r\n * If the client has no server URL, the function returns `SERVER_MODE.LOCAL`.\r\n * Otherwise, it checks if the server page exists by making a fetch request to the server URL.\r\n * If the request is successful (response.ok), the function returns `SERVER_MODE.REMOTE`.\r\n * If the request times out or fails, the function throws an error with the appropriate message.\r\n *\r\n * @param {object} client - The client object containing the server URL.\r\n * @param {number} [timeout=SERVER_REQUEST_DEFAULT_TIMEOUT] - The timeout in milliseconds for the server request.\r\n * @returns {string} - The server mode, either `SERVER_MODE.LOCAL` or `SERVER_MODE.REMOTE`.\r\n * @throws {Error} - If the server page cannot be located or the request fails.\r\n */\r\nexport async function getServerMode(client) {\r\n\r\n  const serverUrl = client.serverUrl\r\n  const timeout = client.serverRequestTimeout || SERVER_REQUEST_DEFAULT_TIMEOUT\r\n\r\n  if (!serverUrl) {\r\n    return SERVER_MODE.LOCAL\r\n  }\r\n\r\n  // Check if server page exists\r\n  const controller = new AbortController()\r\n  let response\r\n  let timeoutHandle\r\n\r\n  try {\r\n    timeoutHandle = setTimeout(() => {\r\n      console.warn(`Request timed out after ${timeout}ms. Aborting request...`)\r\n      controller.abort()\r\n    }, timeout)\r\n\r\n    response = await fetch(serverUrl, { signal: controller.signal })\r\n\r\n    if (response.ok) {\r\n      return SERVER_MODE.REMOTE\r\n    }\r\n  } catch (error) {\r\n\r\n    if (controller.signal.aborted) {\r\n      // throw new Error(`Unable to locate server page. The request timed out after ${timeout}ms. url: ${serverUrl.href}`)\r\n      console.error(`Unable to locate server page. The request timed out after ${timeout}ms. url: ${serverUrl.href}`)\r\n      return SERVER_MODE.LOCAL\r\n    }\r\n\r\n    // throw new Error(`Unable to locate server page : ${serverUrl.href}.`, error)\r\n    console.error(`Unable to locate server page : ${serverUrl.href}.`, error)\r\n    return SERVER_MODE.LOCAL\r\n  } finally {\r\n    clearTimeout(timeoutHandle)\r\n  }\r\n\r\n  // throw new Error(`Unable to locate server page. The request failed with status code ${response.status}. url: ${serverUrl.href}`)\r\n}"],"names":["getKeyName","key","PREFIX","container","targetUrl","root","document","body","origin","postmessageUtils","resolveOrigin","iframeId","iframe","querySelector","createElement","id","hasBooleanParam","style","cssText","ariaHidden","tabIndex","hidden","setProperty","appendChild","src","server","contentWindow","contentDocument","parentWindow","i","async","client","serverUrl","timeout","serverRequestTimeout","SERVER_REQUEST_DEFAULT_TIMEOUT","SERVER_MODE","LOCAL","controller","AbortController","response","timeoutHandle","setTimeout","console","warn","abort","fetch","signal","ok","REMOTE","error","aborted","href","clearTimeout"],"mappings":"uIASO,SAASA,EAAWC,GACzB,MAAO,GAAGC,EAAAA,UAAUD,GACtB,yBAQO,SACLE,EACAC,GAEA,MAAMC,OAAAA,IAAcF,EAA4BA,EAAYG,SAASC,KAC/DC,EAASC,EAAAA,MAAiBC,cAAcN,GACxCO,EAAWX,EAAW,UACxBY,IAAAA,EAwBJ,OAvBIN,SAASO,cAAc,IAAIF,KAC7BC,EAASN,SAASO,cAAc,IAAIF,MAEpCC,EAASN,SAASQ,cAAc,UAChCF,EAAOG,GAAKJ,EAEMK,EAAAA,gBAAgBZ,EAAW,SAQ3CQ,EAAOK,MAAMC,QAAU,yCALvBN,EAAOO,cACPP,EAAOQ,UACPR,EAAAA,EAAOS,UACPT,EAAOK,MAAMK,YAAY,UAAW,SAKtCjB,EAAKkB,YAAYX,GACjBA,EAAOY,IAAMpB,GAKR,CACLqB,OAHmBb,EAAOc,eAAiBd,EAAOe,gBAAgBC,aAIlEpB,SACAI,OAEJiB,EAAA,6CAeOC,eAA6BC,GAElC,MAAMC,EAAYD,EAAOC,UACnBC,EAAUF,EAAOG,sBAAwBC,EAA8BA,+BAE7E,IAAKH,EACII,OAAAA,EAAWA,YAACC,MAIrB,MAAMC,EAAa,IAAIC,gBACvB,IAAIC,EACAC,EAEJ,IACEA,GAAAA,EAAgBC,YAAW,KACzBC,QAAQC,KAAK,2BAA2BX,4BACxCK,EAAWO,OAAO,GACjBZ,GAEHO,QAAiBM,MAAMd,EAAW,CAAEe,OAAQT,EAAWS,SAEnDP,EAASQ,GACX,OAAOZ,EAAWA,YAACa,MAEtB,OAAQC,GAEHZ,OAAAA,EAAWS,OAAOI,SAEpBR,QAAQO,MAAM,6DAA6DjB,aAAmBD,EAAUoB,QACjGhB,EAAWA,YAACC,QAIrBM,QAAQO,MAAM,kCAAkClB,EAAUoB,QAASF,GAC5Dd,EAAWA,YAACC,MACvB,CAAY,QACRgB,aAAaZ,EACd,CAGH"}