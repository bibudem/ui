{"version":3,"file":"utils.cjs","sources":["../src/components/bib-consent/utils.js"],"sourcesContent":["import { utils as postmessageUtils } from 'postmessage-promise'\nimport { hasBooleanParam } from '@/utils/url.js'\nimport { PREFIX, SERVER_MODE, SERVER_REQUEST_DEFAULT_TIMEOUT } from './constants.js'\n\n/**\n * Creates a prefixed key name for the BIB consent module.\n * @param {string} key - The key to be prefixed.\n * @returns {string} - The prefixed key name.\n */\nexport function getKeyName(key) {\n  return `${PREFIX}-${key}`\n}\n\n/**\n * Gets an iframe server for a given target URL.\n * @param {HTMLElement} [container=document.body] - The container element for the iframe.\n * @param {string} targetUrl - The target URL for the iframe.\n * @returns {object} - An object containing the iframe server, origin, and the iframe element.\n */\nexport function getIframeServer(\n  container,\n  targetUrl,\n) {\n  const root = typeof container !== 'undefined' ? container : document.body\n  const origin = postmessageUtils.resolveOrigin(targetUrl)\n  const iframeId = getKeyName('iframe')\n  let iframe\n  if (document.querySelector(`#${iframeId}`)) {\n    iframe = document.querySelector(`#${iframeId}`)\n  } else {\n    iframe = document.createElement('iframe')\n    iframe.id = iframeId\n\n    const isDebugOn = hasBooleanParam(targetUrl, 'debug')\n\n    if (!isDebugOn) {\n      iframe.ariaHidden = true\n      iframe.tabIndex = -1\n      iframe.hidden = true\n      iframe.style.setProperty('display', 'none')\n    } else {\n      iframe.style.cssText = 'width: 100%; height: 100%; border: 0;'\n    }\n\n    root.appendChild(iframe)\n    iframe.src = targetUrl\n  }\n\n  const iframeWindow = iframe.contentWindow || iframe.contentDocument.parentWindow\n\n  return {\n    server: iframeWindow,\n    origin,\n    iframe,\n  }\n}\n\n/**\n * Checks the server mode for a given client.\n * \n * If the client has no server URL, the function returns `SERVER_MODE.LOCAL`.\n * Otherwise, it checks if the server page exists by making a fetch request to the server URL.\n * If the request is successful (response.ok), the function returns `SERVER_MODE.REMOTE`.\n * If the request times out or fails, the function throws an error with the appropriate message.\n *\n * @param {object} client - The client object containing the server URL.\n * @param {number} [timeout=SERVER_REQUEST_DEFAULT_TIMEOUT] - The timeout in milliseconds for the server request.\n * @returns {string} - The server mode, either `SERVER_MODE.LOCAL` or `SERVER_MODE.REMOTE`.\n * @throws {Error} - If the server page cannot be located or the request fails.\n */\nexport async function getServerMode(client) {\n\n  const serverUrl = client.serverUrl\n  const timeout = client.serverRequestTimeout || SERVER_REQUEST_DEFAULT_TIMEOUT\n\n  if (!serverUrl) {\n    return SERVER_MODE.LOCAL\n  }\n\n  // Check if server page exists\n  const controller = new AbortController()\n  let response\n  let timeoutHandle\n\n  try {\n    timeoutHandle = setTimeout(() => {\n      console.warn(`Request timed out after ${timeout}ms. Aborting request...`)\n      controller.abort()\n    }, timeout)\n\n    response = await fetch(serverUrl, { signal: controller.signal })\n\n    if (response.ok) {\n      return SERVER_MODE.REMOTE\n    }\n  } catch (error) {\n\n    if (controller.signal.aborted) {\n      // throw new Error(`Unable to locate server page. The request timed out after ${timeout}ms. url: ${serverUrl.href}`)\n      console.error(`Unable to locate server page. The request timed out after ${timeout}ms. url: ${serverUrl.href}`)\n      return SERVER_MODE.LOCAL\n    }\n\n    // throw new Error(`Unable to locate server page : ${serverUrl.href}.`, error)\n    console.error(`Unable to locate server page : ${serverUrl.href}.`, error)\n    return SERVER_MODE.LOCAL\n  } finally {\n    clearTimeout(timeoutHandle)\n  }\n\n  // throw new Error(`Unable to locate server page. The request failed with status code ${response.status}. url: ${serverUrl.href}`)\n}"],"names":["getKeyName","key","PREFIX","container","targetUrl","root","document","body","origin","postmessageUtils","resolveOrigin","iframeId","iframe","querySelector","createElement","id","hasBooleanParam","style","cssText","ariaHidden","tabIndex","hidden","setProperty","appendChild","src","server","contentWindow","contentDocument","parentWindow","i","async","client","serverUrl","timeout","serverRequestTimeout","SERVER_REQUEST_DEFAULT_TIMEOUT","SERVER_MODE","LOCAL","controller","AbortController","response","timeoutHandle","setTimeout","console","warn","abort","fetch","signal","ok","REMOTE","error","aborted","href","clearTimeout"],"mappings":"uIASO,SAASA,EAAWC,GACzB,MAAO,GAAGC,EAAAA,UAAUD,GACtB,yBAQO,SACLE,EACAC,GAEA,MAAMC,OAAAA,IAAcF,EAA4BA,EAAYG,SAASC,KAC/DC,EAASC,EAAAA,MAAiBC,cAAcN,GACxCO,EAAWX,EAAW,UACxBY,IAAAA,EAwBJ,OAvBIN,SAASO,cAAc,IAAIF,KAC7BC,EAASN,SAASO,cAAc,IAAIF,MAEpCC,EAASN,SAASQ,cAAc,UAChCF,EAAOG,GAAKJ,EAEMK,EAAAA,gBAAgBZ,EAAW,SAQ3CQ,EAAOK,MAAMC,QAAU,yCALvBN,EAAOO,cACPP,EAAOQ,UACPR,EAAAA,EAAOS,UACPT,EAAOK,MAAMK,YAAY,UAAW,SAKtCjB,EAAKkB,YAAYX,GACjBA,EAAOY,IAAMpB,GAKR,CACLqB,OAHmBb,EAAOc,eAAiBd,EAAOe,gBAAgBC,aAIlEpB,SACAI,OAEJiB,EAAA,6CAeOC,eAA6BC,GAElC,MAAMC,EAAYD,EAAOC,UACnBC,EAAUF,EAAOG,sBAAwBC,EAA8BA,+BAE7E,IAAKH,EACII,OAAAA,EAAWA,YAACC,MAIrB,MAAMC,EAAa,IAAIC,gBACvB,IAAIC,EACAC,EAEJ,IACEA,GAAAA,EAAgBC,YAAW,KACzBC,QAAQC,KAAK,2BAA2BX,4BACxCK,EAAWO,OAAO,GACjBZ,GAEHO,QAAiBM,MAAMd,EAAW,CAAEe,OAAQT,EAAWS,SAEnDP,EAASQ,GACX,OAAOZ,EAAWA,YAACa,MAEtB,OAAQC,GAEHZ,OAAAA,EAAWS,OAAOI,SAEpBR,QAAQO,MAAM,6DAA6DjB,aAAmBD,EAAUoB,QACjGhB,EAAWA,YAACC,QAIrBM,QAAQO,MAAM,kCAAkClB,EAAUoB,QAASF,GAC5Dd,EAAWA,YAACC,MACvB,CAAY,QACRgB,aAAaZ,EACd,CAGH"}